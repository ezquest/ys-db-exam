
# ezquest-DB Summary

#### 1. Key 개념
<pre>
 - Key는 DB에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때,
   다른 튜플들과 구별할 수 있는 유일한 기준이 되는 attribute 속성
  1) 후보키
   - 유일하게 식별할 수 있는 속성들의 부분집합
   - 유일성과 최소성을 만족
  2) 기본키
   - 특정 튜플을 유일하게 구별 할 수 있는 속성
  3) 대체키
   - 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 말함
  4) 슈퍼키
   - 릴레이션 내에 있는 속성들의 집합으로 구성된 키
   - 유일성은 만족하지만, 최소성은 만족하지 않음
  5) 외래키
   - 참조되는 릴레이션의 기본키와 대응되는 릴레이션 간에 참조 관계를 표현하는데 중요한 도구
</pre>

#### 2. Relational algebra
<pre>
 - select: σ
 - project: π
 - union: U
 - set difference: -
 - cartesian product: x
 - rename: ρ
</pre>

#### 4. View 개념
<pre>
 - 허용된 데이터를 제한적으로 보여주기 위해서 하나 이상의 테이블에서부터 유도된 가상 테이블
</pre>

#### 5. Cursor 개념, Prepared statement
<pre>
 Cursor: 내장 sql문의 수행결과로 반환 될 수 있는 복수의 튜플들을 액세스 할 수 있도록 해주는 개념
  - Declare: 커서를 정의하는 등 커서에 관련된 선언을 하는 명령
  - Open: 커서가 질의 결과의 첫 번째 튜플을 포인트 하도록 설정하는 명령
  - Fetch: 질의 결과의 튜플들 중 현재의 다음 튜플로 커서 이동
  - Close: 질의 수행 결과에 대한 처리 종료 시 커서를 닫기 위해 사용
 Prepared statement: Statement를 상속받는 인터페이스, sql 구문을 실행시키는 기능을 갖는 객체
</pre>

#### 6. Reduction to relational schemas
<pre>
 - 엔티티 집합과 관계집합은 데이터베이스의 내용을 표현하는 릴레이션(테이블) 스키마로 균일하게 나타낼 수 있다.
 - ER도에 상응하는 데이터 베이스는 릴레이션의 모임으로 표현될 수 있다.
 - 각 엔티티 집합과 관계 집합에 대해 그에 상응하는 이름이 할당된 유일한 릴레이션이 존재한다.
 - 각 릴레이션은 고유한 이름을 가진 여러 개의 열을 가진다.
</pre>

#### 7. Slotted page structure
<pre>
 - DBMS에 관리되는 데이터는 대부분 크기가 작으며, 수량이 많고, 시간이 지날수록 증가한다. 
   따라서 크기가 작은 많은 양의 레코드를 가변적으로 저장하기 위해 힙 파일을 linked List로
   구성된 여러 개의 페이지로 구성되어 있고, 한 페이지에 여러 레코드를 저장하기 위해 slotted page를 사용한다.
 - 페이지의 헤더에는 페이지의 id, 소유자, 남은 공간 등 여러 정보와 슬롯테이블이 있다. 
   각 슬롯은 실제 레코드의 주소를 가진다. 페이지 내에서 레코드가 이동할 때는 슬롯번호가 바뀌지는 않고,
   슬롯에 있는 페이지 내 주소만 변경하면 된다. 외부에서는 페이지 번호와 슬롯 번호만 알면 해당 레코드를 접근할 수 있다.
 # 각 블럭의 첫 부분에 헤더가 있다.
 # 헤더의 포함되는 요소는 다음과 같다.
  - 레코드수, Free space의 끝, 레코드별 위치와 크기를 담은 배열
 # 레코드는 블럭 끝에서부터 연속적으로 할당된다.
</pre>

#### 8. Multitable clustering file organization
<pre>
 - 다수의 릴레이션을 하나의 파일에 저장한다.
 - 한번의 I/O연산으로 관련된 레코드들을 가져올 수 있다.
 - 다른 릴레이션들의 관련된 레코드들을 하나의 클러스터에 저장한다.
</pre>

#### 9. Primary index vs. secondary index
<pre>
 - 유사점
  1) 데이터베이스에서 분리된 객체, 테이블과 그에 대응되는 인덱스는 서로 분리된 구조로 존재
  2) 둘 다 질의 문들은 먼저 인덱스를 찾아보고, 그것이 가리키는 레코드들을 적재하여 결과로 사용한다.
  3) 두 중류의 인덱스들 안에 존재하는 인덱스 블록들은 정렬된 엔트리들을 보관한다.
 - 차이점
  1) 기본인덱스
   - 데이터 블록 안에 행들의 조직과 저장소에 영향을 미친다.
   - 데이터 블록들의 실제 행 데이터를 저장하는 디스크 블록들이다.
   - 데이터 블록 안의 행들을 통해 인덱스 키를 정렬
   - 데이터 블록 안의 행들의 정렬을 강요한다.
   - 키와 비키 칼럼에서 생성될 수 있다. 기본 인덱스는 오직 기본키만 사용 가능하지는 않다. 
     물론 일반적으로 기본키를 기반으로 생성한다.
   - 하나의 테이블에 오직 하나의 기본 인덱스만 가질 수 있다.
  2) 보조 인덱스 
   - 데이터 블록에서 실제로 조직화된 행들에 전혀 영향을 미치지 않는다.
   - 보조 인덱스는 순서를 가지지 않는다. (정렬되지 않아도 상관없다.) 
   - 인덱스 블록의 인덱스 키만 정렬 되어야 한다.
</pre>

#### 10. B+ tree, B tree
<pre>
 - 
</pre>
